---
import { cld } from '../lib/cloudinary'

const { images, slug } = Astro.props
---

<section class="gallery" data-slug={slug}>
  {images?.map((id: string, index: number) => (
    <figure class="gallery-item">
      <img
        src={cld(id, slug, { width: 600, quality: 'auto', format: 'auto' })}
        srcset={`
          ${cld(id, slug, { width: 400, quality: 'auto', format: 'auto' })} 400w,
          ${cld(id, slug, { width: 600, quality: 'auto', format: 'auto' })} 600w,
          ${cld(id, slug, { width: 900, quality: 'auto', format: 'auto' })} 900w
        `}
        sizes="(max-width: 640px) 100vw, (max-width: 1200px) 50vw, 33vw"
        loading="lazy"
        decoding="async"
        alt=""
        data-index={index}
        class="gallery-image"
      />
    </figure>
  ))}
</section>

<div id="lightbox" class="lightbox">
  <button class="lightbox-close" aria-label="Close">&times;</button>
  <div class="lightbox-content">
    <div class="lightbox-loader-overlay">
      <div class="lightbox-loading"></div>
    </div>
    <img id="lightbox-image" src="" alt="" />
  </div>
  <button class="lightbox-prev" aria-label="Previous">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
  </button>
  <button class="lightbox-next" aria-label="Next">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </button>
</div>

<style>
  .gallery {
    display: grid;
    gap: 1.5rem;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  }

  .gallery-item {
    margin: 0;
    position: relative;
    overflow: hidden;
    border-radius: 12px;
    background: #0f1114;
    cursor: pointer;
  }

  .gallery-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    aspect-ratio: 4 / 3;
    transition: transform 300ms ease;
  }

  .gallery-item:hover img {
    transform: scale(1.03);
  }

  .lightbox {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(5, 6, 7, 0.95);
    z-index: 1000;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
  }

  .lightbox.active {
    display: flex;
  }

  .lightbox-content {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    padding: 4rem;
  }

  #lightbox-image {
    max-width: 90vw;
    max-height: 90vh;
    width: auto;
    height: auto;
    object-fit: contain;
    border-radius: 8px;
    position: relative;
    z-index: 1;
  }

  .lightbox-loader-overlay {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.55);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2;
  }

  .lightbox-loading {
    position: relative;
    width: 36px;
    height: 36px;
    border: 3px solid rgba(245, 245, 247, 0.3);
    border-top-color: var(--fg);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    transform-origin: center;
    z-index: 2;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .lightbox-close,
  .lightbox-prev,
  .lightbox-next {
    position: absolute;
    background: transparent;
    border: none;
    color: var(--fg);
    cursor: pointer;
    transition: color 140ms ease;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    width: 48px;
    height: 48px;
  }

  .lightbox-close:hover,
  .lightbox-prev:hover,
  .lightbox-next:hover {
    color: var(--accent);
  }

  .lightbox-close {
    top: 2rem;
    right: 2rem;
    z-index: 1001;
    font-size: 2.4rem;
    line-height: 1;
  }

  .lightbox-prev {
    left: 2rem;
    top: 50%;
    transform: translateY(-50%);
  }

  .lightbox-next {
    right: 2rem;
    top: 50%;
    transform: translateY(-50%);
  }

  @media (max-width: 768px) {
    .gallery {
      grid-template-columns: 1fr;
      gap: 1rem;
    }

    .lightbox-content {
      padding: 2rem 1rem;
    }

    #lightbox-image {
      max-width: 95vw;
      max-height: 60vh;
    }

    .lightbox-close {
      top: 1rem;
      right: 1rem;
      width: 40px;
      height: 40px;
    }
  }
</style>

<script>
  const setupGallery = () => {
    const gallery = document.querySelector('.gallery') as HTMLElement | null
    const lightbox = document.getElementById('lightbox') as HTMLElement | null
    const lightboxImage = document.getElementById('lightbox-image') as HTMLImageElement | null
    const lightboxOverlay = document.querySelector('.lightbox-loader-overlay') as HTMLElement | null
    const lightboxLoader = document.querySelector('.lightbox-loading') as HTMLElement | null
    const lightboxClose = document.querySelector('.lightbox-close')
    const lightboxPrev = document.querySelector('.lightbox-prev')
    const lightboxNext = document.querySelector('.lightbox-next')
    
    let currentIndex = 0
    let allImages: string[] = []
    const slug = gallery?.dataset.slug || ''
    const CLOUD_NAME = 'mathis-portfolio'
    const preloadCache = new Map<string, Promise<string>>()

    // Sammle alle Bilder aus den data-index Attributen
    const updateAllImages = () => {
      allImages = Array.from(document.querySelectorAll('.gallery-image'))
        .map((img) => {
          const imageId = (img as HTMLImageElement).src.split('/').pop()?.split('?')[0] || ''
          return imageId
        })
        .filter(Boolean)
    }
    
    updateAllImages()

    const cldUrl = (imageId: string, options?: any) => {
      const transforms = []
      if (options?.width) transforms.push(`w_${options.width}`)
      transforms.push(options?.quality ? `q_${options.quality}` : 'q_auto')
      transforms.push(options?.format ? `f_${options.format}` : 'f_auto')
      const transformString = transforms.length > 0 ? `/${transforms.join('/')}` : ''
      return `https://res.cloudinary.com/${CLOUD_NAME}/image/upload${transformString}/portfolio/${slug}/${imageId}`
    }

    const showLoader = () => {
      if (lightboxOverlay) lightboxOverlay.style.display = 'flex'
    }

    const hideLoader = () => {
      if (lightboxOverlay) lightboxOverlay.style.display = 'none'
    }

    // Preload ein Bild (Promise wird gecached, damit mehrfacher Aufruf nicht mehrfach lädt)
    const preloadImage = (imageId: string) => {
      if (preloadCache.has(imageId)) return preloadCache.get(imageId)!

      const promise = new Promise<string>((resolve, reject) => {
        const img = new Image()
        img.onload = () => resolve(img.src)
        img.onerror = reject
        img.src = cldUrl(imageId, { width: 1800, quality: 'auto', format: 'auto' })
      })

      preloadCache.set(imageId, promise)
      return promise
    }

    const loadIntoLightbox = async (imageId: string) => {
      if (!lightboxImage) return
      showLoader()
      try {
        const src = await preloadImage(imageId)
        lightboxImage.src = src
      } finally {
        hideLoader()
      }
    }

    const preloadWindow = (radius = 20) => {
      if (allImages.length === 0) return
      const total = allImages.length
      const maxRadius = Math.min(radius, Math.floor(total / 2))
      for (let step = 1; step <= maxRadius; step++) {
        const nextIndex = (currentIndex + step) % total
        const prevIndex = (currentIndex - step + total) % total
        preloadImage(allImages[nextIndex]).catch(() => {})
        preloadImage(allImages[prevIndex]).catch(() => {})
      }
    }

    const openLightbox = (index: number) => {
      if (!lightbox || !lightboxImage) return
      if (index < 0 || index >= allImages.length) return
      
      currentIndex = index
      lightbox.classList.add('active')
      const imageId = allImages[index]
      loadIntoLightbox(imageId)
      preloadWindow()
      document.body.style.overflow = 'hidden'
    }

    const closeLightbox = () => {
      if (!lightbox) return
      lightbox.classList.remove('active')
      document.body.style.overflow = ''
      hideLoader()
    }

    const showNext = () => {
      if (allImages.length === 0) return
      currentIndex = (currentIndex + 1) % allImages.length
      const imageId = allImages[currentIndex]
      loadIntoLightbox(imageId)
      preloadWindow()
    }

    const showPrev = () => {
      if (allImages.length === 0) return
      currentIndex = (currentIndex - 1 + allImages.length) % allImages.length
      const imageId = allImages[currentIndex]
      loadIntoLightbox(imageId)
      preloadWindow()
    }

    // Simple touch swipe support for mobile (on the lightbox image)
    let touchStartX: number | null = null
    let touchStartY: number | null = null

    const swipeThreshold = 20 // min horizontal movement in px
    const maxVerticalOffset = 80 // ignore mostly vertical swipes

    lightboxImage?.addEventListener('touchstart', (e) => {
      const touch = e.touches[0]
      touchStartX = touch.clientX
      touchStartY = touch.clientY
    })

    lightboxImage?.addEventListener('touchend', (e) => {
      if (touchStartX === null || touchStartY === null) return

      const touch = e.changedTouches[0]
      const dx = touch.clientX - touchStartX
      const dy = touch.clientY - touchStartY

      // Only react to mostly horizontal swipes
      if (Math.abs(dx) > swipeThreshold && Math.abs(dy) < maxVerticalOffset) {
        if (dx < 0) {
          showNext()
        } else {
          showPrev()
        }
      }

      touchStartX = null
      touchStartY = null
    })

    // Desktop: click left/right side of image for prev/next
    if (window.matchMedia && window.matchMedia('(pointer: fine)').matches) {
      lightboxImage?.addEventListener('click', (e: MouseEvent) => {
        if (!lightboxImage) return
        const rect = lightboxImage.getBoundingClientRect()
        const x = e.clientX - rect.left
        if (x < rect.width / 2) {
          showPrev()
        } else {
          showNext()
        }
      })

      // Desktop: click regions around the image
      lightbox?.addEventListener('click', (e: MouseEvent) => {
        if (!lightboxImage) return
        const rect = lightboxImage.getBoundingClientRect()
        const { clientX, clientY } = e

        // If click is above or below the image, close lightbox
        if (clientY < rect.top || clientY > rect.bottom) {
          closeLightbox()
          return
        }

        // If click is left or right outside the image, go prev/next
        if (clientX < rect.left) {
          showPrev()
        } else if (clientX > rect.right) {
          showNext()
        }
      })
    }

    // Setup gallery image clicks
    const setupImageClicks = () => {
      document.querySelectorAll('.gallery-image').forEach((img) => {
        const imgElement = img as HTMLImageElement
        if (!imgElement.dataset.clickHandlerAttached) {
          imgElement.addEventListener('click', () => {
            const index = Array.from(document.querySelectorAll('.gallery-image')).indexOf(img)
            openLightbox(index)
          })
          imgElement.dataset.clickHandlerAttached = 'true'
        }
      })
    }
    
    // Entfernt defekte Bilder aus der Galerie, damit fehlende IDs keinen leeren Slot hinterlassen
    const removeBrokenImage = (imgElement: HTMLImageElement) => {
      const figure = imgElement.closest('.gallery-item')
      figure?.remove()
      updateAllImages()
      setupImageClicks()
      if (lightbox?.classList.contains('active') && allImages.length === 0) {
        closeLightbox()
      }
    }

    // Fehlerhafte Bilder direkt aus dem DOM nehmen
    const setupErrorHandling = () => {
      document.querySelectorAll('.gallery-image').forEach((img) => {
        const imgElement = img as HTMLImageElement
        if (!imgElement.dataset.errorHandlerAttached) {
          imgElement.addEventListener('error', () => removeBrokenImage(imgElement))
          imgElement.dataset.errorHandlerAttached = 'true'
        }
      })
    }
    
    setupImageClicks()
    setupErrorHandling()

    // Button-Klicks
    lightboxClose?.addEventListener('click', (e) => {
      e.preventDefault()
      e.stopPropagation()
      closeLightbox()
    })
    
    lightboxPrev?.addEventListener('click', (e) => {
      e.preventDefault()
      e.stopPropagation()
      showPrev()
    })
    
    lightboxNext?.addEventListener('click', (e) => {
      e.preventDefault()
      e.stopPropagation()
      showNext()
    })

    // Keyboard-Navigation
    document.addEventListener('keydown', (e) => {
      if (!lightbox || !lightbox.classList.contains('active')) return
      if (e.key === 'Escape') closeLightbox()
      if (e.key === 'ArrowRight') showNext()
      if (e.key === 'ArrowLeft') showPrev()
    })
  }

  // Beim Laden und bei Navigation
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupGallery)
  } else {
    setupGallery()
  }

  // Für Astro View Transitions
  document.addEventListener('astro:after-swap', setupGallery)
</script>
